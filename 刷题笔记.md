# 刷题笔记📒

## 1. 链表

### [206]反转链表 {#206}

【链接】：<https://leetcode.cn/problems/reverse-linked-list>

【题目简单描述】：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

【题解】：这个题主要锻炼迭代和递归思维。对于递归解法，指针反转从最后一个开始，整体类似一个 U 形，所以整体反转的链路是从右往左（从下往上）进行的。对于迭代解法，指针反转从第一个开始，整体反转的链路是从左往右进行的。

【代码】：

```go
// reverseListRecursion 递归
func reverseListRecursion(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseListRecursion(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}

// reverseIteration 迭代
func reverseIteration(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

### [25] K 个一组翻转链表

【链接】：<https://leetcode.cn/problems/reverse-nodes-in-k-group/>

【题目简单描述】：给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

【题解】：这个题目是反转链表的进阶版，将链表分为 $\frac{k}{n}$ 组，每组反转可以直接使用 [[206]反转链表](#206) 的反转方法。但需要多考虑的一些点：1. 每组反转完之后需要考虑左侧点和右侧点，左侧点与上一组的右侧点连接；2. 会有剩余节点数小于 k 的情况，这个需要直接忽略。整体而言，就是准确的断开和连接对应的节点。

【代码】：

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    // 如果 k 为 1 ，说明不用反转；只有一个节点也不用反转
    if k == 1 || head.Next == nil {
        return head
    }
    // 左侧节点，用于最后返回
    left := head
    // 左侧节点
    for i := 0; i < k-1; i++ {
        left = left.Next
    }
    // 动态右侧节点，用于每次连接新一组的左侧节点
    right := &ListNode{Next: head}
    for head != nil {
        tmp := head
        // 判断是否满足一组
        for i := 0; i < k-1; i++ {
            if head.Next == nil {
                right.Next = tmp
                return left
            }
            head = head.Next
        }
        // 反转指针
        next := head.Next
        head.Next = nil
        tmpLeft := reverseIteration(tmp)
        right.Next = tmpLeft
        right = tmp
        head = next
    }
    return left
}

// reverseIteration 迭代
func reverseIteration(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

### [21]合并两个有序链表

【链接】：<https://leetcode.cn/problems/merge-two-sorted-lists/>

【题目简单描述】：将两个升序链表合并为一个新的**升序**链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

【题解】：遍历比较两个链表最左侧的值即可，需要注意的是要在条件判断（大小比较）结束时`continue`出去。然后判断是否有剩余，把剩余的给补上去。

【代码】：

```go
// mergeTwoLists 合并两个有序链表(升序)
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    curr := &ListNode{}
    resList := curr
    p1, p2 := list1, list2
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            next := p1.Next
            curr.Next = p1
            p1 = next
            curr = curr.Next
            continue
        }
        next := p2.Next
        curr.Next = p2
        p2 = next
        curr = curr.Next
    }
    if p1 != nil {
        curr.Next = p1
    }
    if p2 != nil {
        curr.Next = p2
    }
    return resList.Next
}
```

## 2. 数组

### [704] 二分查找

【链接】：<https://leetcode.cn/problems/binary-search/>

【题目简单描述】：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**示例 1:**

> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4

**示例 2:**

> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1

**提示：**

1. 你可以假设 nums 中的所有元素是不重复的。
2. n 将在 [1, 10000]之间。
3. nums 的每个元素都将在 [-9999, 9999]之间。

【题解】：二分查找的核心思想是分治，对于升序数组，将 target 与数组边界的中间值进行比较，如果等于，直接返回；如果小于，右边界等于中间值；如果大于，左边界等于中间值。
这里需要小心区间问题，`[l, r]`和 `[l, r)` 的处理方法不一致。

【代码】：

```go
// search 二分查找 [l, r]
func search(nums []int, target int) int {
    l, r := 0, len(nums) - 1
    for l <= r {
        m := ((r - l)>>1) + l // 位运算 + 防止大数溢出
        if target == nums[m] {
            return m
        } else if target < nums[m] {
            r = m - 1
        }else{
            l = m + 1
        }
    }
    return -1
}

// search 二分查找 [l, r)
func search(nums []int, target int) int {
    l, r := 0, len(nums) - 1
    for l < r {
        m := ((r - l)>>1) + l
        if target == nums[m] {
            return m
        } else if target < nums[m] {
            r = m
        }else{
            l = m + 1
        }
    }
    return -1
}
```

## 3. 栈

## 4. 队列

## 5. 哈希表

## 6. 树

## 7. 堆

## 8. 图

## 9. 搜索

## 10. 排序

## 11. 分治

## 12. 回溯

## 13. 动态规划

## 14. 贪心
