# åˆ·é¢˜ç¬”è®°ğŸ“’

## 1. é“¾è¡¨

### [206]åè½¬é“¾è¡¨ {#206}

ã€é“¾æ¥ã€‘ï¼š<https://leetcode.cn/problems/reverse-linked-list>

ã€é¢˜ç›®ç®€å•æè¿°ã€‘ï¼šç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚

ã€é¢˜è§£ã€‘ï¼šè¿™ä¸ªé¢˜ä¸»è¦é”»ç‚¼è¿­ä»£å’Œé€’å½’æ€ç»´ã€‚å¯¹äºé€’å½’è§£æ³•ï¼ŒæŒ‡é’ˆåè½¬ä»æœ€åä¸€ä¸ªå¼€å§‹ï¼Œæ•´ä½“ç±»ä¼¼ä¸€ä¸ª U å½¢ï¼Œæ‰€ä»¥æ•´ä½“åè½¬çš„é“¾è·¯æ˜¯ä»å³å¾€å·¦ï¼ˆä»ä¸‹å¾€ä¸Šï¼‰è¿›è¡Œçš„ã€‚å¯¹äºè¿­ä»£è§£æ³•ï¼ŒæŒ‡é’ˆåè½¬ä»ç¬¬ä¸€ä¸ªå¼€å§‹ï¼Œæ•´ä½“åè½¬çš„é“¾è·¯æ˜¯ä»å·¦å¾€å³è¿›è¡Œçš„ã€‚

ã€ä»£ç ã€‘ï¼š

```go
// reverseListRecursion é€’å½’
func reverseListRecursion(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseListRecursion(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}

// reverseIteration è¿­ä»£
func reverseIteration(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

### [25] K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

ã€é“¾æ¥ã€‘ï¼š<https://leetcode.cn/problems/reverse-nodes-in-k-group/>

ã€é¢˜ç›®ç®€å•æè¿°ã€‘ï¼šç»™ä½ é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œæ¯ k ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ä¿®æ”¹åçš„é“¾è¡¨ã€‚k æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ k çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºã€‚ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚

ã€é¢˜è§£ã€‘ï¼šè¿™ä¸ªé¢˜ç›®æ˜¯åè½¬é“¾è¡¨çš„è¿›é˜¶ç‰ˆï¼Œå°†é“¾è¡¨åˆ†ä¸º $\frac{k}{n}$ ç»„ï¼Œæ¯ç»„åè½¬å¯ä»¥ç›´æ¥ä½¿ç”¨ [[206]åè½¬é“¾è¡¨](#206) çš„åè½¬æ–¹æ³•ã€‚ä½†éœ€è¦å¤šè€ƒè™‘çš„ä¸€äº›ç‚¹ï¼š1. æ¯ç»„åè½¬å®Œä¹‹åéœ€è¦è€ƒè™‘å·¦ä¾§ç‚¹å’Œå³ä¾§ç‚¹ï¼Œå·¦ä¾§ç‚¹ä¸ä¸Šä¸€ç»„çš„å³ä¾§ç‚¹è¿æ¥ï¼›2. ä¼šæœ‰å‰©ä½™èŠ‚ç‚¹æ•°å°äº k çš„æƒ…å†µï¼Œè¿™ä¸ªéœ€è¦ç›´æ¥å¿½ç•¥ã€‚æ•´ä½“è€Œè¨€ï¼Œå°±æ˜¯å‡†ç¡®çš„æ–­å¼€å’Œè¿æ¥å¯¹åº”çš„èŠ‚ç‚¹ã€‚

ã€ä»£ç ã€‘ï¼š

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    // å¦‚æœ k ä¸º 1 ï¼Œè¯´æ˜ä¸ç”¨åè½¬ï¼›åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿä¸ç”¨åè½¬
    if k == 1 || head.Next == nil {
        return head
    }
    // å·¦ä¾§èŠ‚ç‚¹ï¼Œç”¨äºæœ€åè¿”å›
    left := head
    // å·¦ä¾§èŠ‚ç‚¹
    for i := 0; i < k-1; i++ {
        left = left.Next
    }
    // åŠ¨æ€å³ä¾§èŠ‚ç‚¹ï¼Œç”¨äºæ¯æ¬¡è¿æ¥æ–°ä¸€ç»„çš„å·¦ä¾§èŠ‚ç‚¹
    right := &ListNode{Next: head}
    for head != nil {
        tmp := head
        // åˆ¤æ–­æ˜¯å¦æ»¡è¶³ä¸€ç»„
        for i := 0; i < k-1; i++ {
            if head.Next == nil {
                right.Next = tmp
                return left
            }
            head = head.Next
        }
        // åè½¬æŒ‡é’ˆ
        next := head.Next
        head.Next = nil
        tmpLeft := reverseIteration(tmp)
        right.Next = tmpLeft
        right = tmp
        head = next
    }
    return left
}

// reverseIteration è¿­ä»£
func reverseIteration(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

### [21]åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

ã€é“¾æ¥ã€‘ï¼š<https://leetcode.cn/problems/merge-two-sorted-lists/>

ã€é¢˜ç›®ç®€å•æè¿°ã€‘ï¼šå°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„**å‡åº**é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚

ã€é¢˜è§£ã€‘ï¼šéå†æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨æœ€å·¦ä¾§çš„å€¼å³å¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯è¦åœ¨æ¡ä»¶åˆ¤æ–­ï¼ˆå¤§å°æ¯”è¾ƒï¼‰ç»“æŸæ—¶`continue`å‡ºå»ã€‚ç„¶ååˆ¤æ–­æ˜¯å¦æœ‰å‰©ä½™ï¼ŒæŠŠå‰©ä½™çš„ç»™è¡¥ä¸Šå»ã€‚

ã€ä»£ç ã€‘ï¼š

```go
// mergeTwoLists åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨(å‡åº)
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    curr := &ListNode{}
    resList := curr
    p1, p2 := list1, list2
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            next := p1.Next
            curr.Next = p1
            p1 = next
            curr = curr.Next
            continue
        }
        next := p2.Next
        curr.Next = p2
        p2 = next
        curr = curr.Next
    }
    if p1 != nil {
        curr.Next = p1
    }
    if p2 != nil {
        curr.Next = p2
    }
    return resList.Next
}
```

## 2. æ•°ç»„

### [704] äºŒåˆ†æŸ¥æ‰¾

ã€é“¾æ¥ã€‘ï¼š<https://leetcode.cn/problems/binary-search/>

ã€é¢˜ç›®ç®€å•æè¿°ã€‘ï¼šç»™å®šä¸€ä¸ª n ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ target ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢ nums ä¸­çš„ targetï¼Œå¦‚æœç›®æ ‡å€¼å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚

**ç¤ºä¾‹ 1:**

> è¾“å…¥: nums = [-1,0,3,5,9,12], target = 9
> è¾“å‡º: 4
> è§£é‡Š: 9 å‡ºç°åœ¨ nums ä¸­å¹¶ä¸”ä¸‹æ ‡ä¸º 4

**ç¤ºä¾‹ 2:**

> è¾“å…¥: nums = [-1,0,3,5,9,12], target = 2
> è¾“å‡º: -1
> è§£é‡Š: 2 ä¸å­˜åœ¨ nums ä¸­å› æ­¤è¿”å› -1

**æç¤ºï¼š**

1. ä½ å¯ä»¥å‡è®¾ nums ä¸­çš„æ‰€æœ‰å…ƒç´ æ˜¯ä¸é‡å¤çš„ã€‚
2. n å°†åœ¨ [1, 10000]ä¹‹é—´ã€‚
3. nums çš„æ¯ä¸ªå…ƒç´ éƒ½å°†åœ¨ [-9999, 9999]ä¹‹é—´ã€‚

ã€é¢˜è§£ã€‘ï¼šäºŒåˆ†æŸ¥æ‰¾çš„æ ¸å¿ƒæ€æƒ³æ˜¯åˆ†æ²»ï¼Œå¯¹äºå‡åºæ•°ç»„ï¼Œå°† target ä¸æ•°ç»„è¾¹ç•Œçš„ä¸­é—´å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœç­‰äºï¼Œç›´æ¥è¿”å›ï¼›å¦‚æœå°äºï¼Œå³è¾¹ç•Œç­‰äºä¸­é—´å€¼ï¼›å¦‚æœå¤§äºï¼Œå·¦è¾¹ç•Œç­‰äºä¸­é—´å€¼ã€‚
è¿™é‡Œéœ€è¦å°å¿ƒåŒºé—´é—®é¢˜ï¼Œ`[l, r]`å’Œ `[l, r)` çš„å¤„ç†æ–¹æ³•ä¸ä¸€è‡´ã€‚

ã€ä»£ç ã€‘ï¼š

```go
// search äºŒåˆ†æŸ¥æ‰¾ [l, r]
func search(nums []int, target int) int {
    l, r := 0, len(nums) - 1
    for l <= r {
        m := ((r - l)>>1) + l // ä½è¿ç®— + é˜²æ­¢å¤§æ•°æº¢å‡º
        if target == nums[m] {
            return m
        } else if target < nums[m] {
            r = m - 1
        }else{
            l = m + 1
        }
    }
    return -1
}

// search äºŒåˆ†æŸ¥æ‰¾ [l, r)
func search(nums []int, target int) int {
    l, r := 0, len(nums) - 1
    for l < r {
        m := ((r - l)>>1) + l
        if target == nums[m] {
            return m
        } else if target < nums[m] {
            r = m
        }else{
            l = m + 1
        }
    }
    return -1
}
```

### [27]ç§»é™¤å…ƒç´ 

ã€é“¾æ¥ã€‘ï¼š<https://leetcode.cn/problems/remove-element/>
ã€é¢˜ç›®æè¿°ã€‘ï¼š
ç»™ä½ ä¸€ä¸ªæ•°ç»„ `nums` å’Œä¸€ä¸ªå€¼ `val`ï¼Œä½ éœ€è¦ **åŸåœ°** ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äº `val` çš„å…ƒç´ ã€‚å…ƒç´ çš„é¡ºåºå¯èƒ½å‘ç”Ÿæ”¹å˜ã€‚ç„¶åè¿”å› `nums` ä¸­ä¸ `val` ä¸åŒçš„å…ƒç´ çš„æ•°é‡ã€‚

å‡è®¾ `nums` ä¸­ä¸ç­‰äº `val` çš„å…ƒç´ æ•°é‡ä¸º `k`ï¼Œè¦é€šè¿‡æ­¤é¢˜ï¼Œæ‚¨éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

- æ›´æ”¹ `nums` æ•°ç»„ï¼Œä½¿ `nums` çš„å‰ `k` ä¸ªå…ƒç´ åŒ…å«ä¸ç­‰äº `val` çš„å…ƒç´ ã€‚`nums` çš„å…¶ä½™å…ƒç´ å’Œ `nums` çš„å¤§å°å¹¶ä¸é‡è¦ã€‚
- è¿”å› `k`ã€‚

**ç”¨æˆ·è¯„æµ‹ï¼š**

è¯„æµ‹æœºå°†ä½¿ç”¨ä»¥ä¸‹ä»£ç æµ‹è¯•æ‚¨çš„è§£å†³æ–¹æ¡ˆï¼š

```plaintext
int[] nums = [...]; // è¾“å…¥æ•°ç»„
int val = ...; // è¦ç§»é™¤çš„å€¼
int[] expectedNums = [...]; // é•¿åº¦æ­£ç¡®çš„é¢„æœŸç­”æ¡ˆã€‚
                            // å®ƒä»¥ä¸ç­‰äº val çš„å€¼æ’åºã€‚

int k = removeElement(nums, val); // è°ƒç”¨ä½ çš„å®ç°

assert k == expectedNums.length;
sort(nums, 0, k); // æ’åº nums çš„å‰ k ä¸ªå…ƒç´ 
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

å¦‚æœæ‰€æœ‰çš„æ–­è¨€éƒ½é€šè¿‡ï¼Œä½ çš„è§£å†³æ–¹æ¡ˆå°†ä¼š **é€šè¿‡**ã€‚

**ç¤ºä¾‹ 1ï¼š**

```plaintext
è¾“å…¥ï¼šnums = [3,2,2,3], val = 3
è¾“å‡ºï¼š2, nums = [2,2,_,_]
è§£é‡Šï¼šä½ çš„å‡½æ•°å‡½æ•°åº”è¯¥è¿”å› k = 2, å¹¶ä¸” nums ä¸­çš„å‰ä¸¤ä¸ªå…ƒç´ å‡ä¸º 2ã€‚
ä½ åœ¨è¿”å›çš„ k ä¸ªå…ƒç´ ä¹‹å¤–ç•™ä¸‹äº†ä»€ä¹ˆå¹¶ä¸é‡è¦ï¼ˆå› æ­¤å®ƒä»¬å¹¶ä¸è®¡å…¥è¯„æµ‹ï¼‰ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```plaintext
è¾“å…¥ï¼šnums = [0,1,2,2,3,0,4,2], val = 2
è¾“å‡ºï¼š5, nums = [0,1,4,0,3,_,_,_]
è§£é‡Šï¼šä½ çš„å‡½æ•°åº”è¯¥è¿”å› k = 5ï¼Œå¹¶ä¸” nums ä¸­çš„å‰äº”ä¸ªå…ƒç´ ä¸º 0,0,1,3,4ã€‚
æ³¨æ„è¿™äº”ä¸ªå…ƒç´ å¯ä»¥ä»»æ„é¡ºåºè¿”å›ã€‚
ä½ åœ¨è¿”å›çš„ k ä¸ªå…ƒç´ ä¹‹å¤–ç•™ä¸‹äº†ä»€ä¹ˆå¹¶ä¸é‡è¦ï¼ˆå› æ­¤å®ƒä»¬å¹¶ä¸è®¡å…¥è¯„æµ‹ï¼‰ã€‚
```

**æç¤ºï¼š**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

ã€é¢˜è§£ã€‘ï¼šç§»é™¤å…ƒç´ çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä½¿ç”¨å·¦å³åŒæŒ‡é’ˆè¿›è¡Œæ•°çš„äº¤æ¢ï¼Œå¦‚æœæ˜¯è¦ç§»é™¤çš„å…ƒç´ ï¼ŒlæŒ‡å‘çš„å€¼å˜ä¸ºræŒ‡é’ˆæŒ‡å‘çš„å€¼ï¼Œç„¶årå·¦ç§»ä¸€ä¸ªï¼ŒåŸæ¥ræŒ‡å‘çš„å€¼å˜ä¸º-1. æœ€åç›´åˆ°lä¸rç›¸é‡ï¼Œè¿™é‡Œæ˜¯[l, r]é—­åŒºé—´ï¼Œæ‰€ä»¥éœ€è¦ç­‰åˆ°l=ræ—¶ç»“æŸã€‚

ã€ä»£ç ã€‘ï¼š

```go
// removeElement ç§»é™¤å…ƒç´ 
func removeElement(nums []int, val int) int {
    if len(nums) == 0 {
        return 0
    }
    l, r := 0, len(nums) - 1
    for l <= r {
        if nums[l] == val {
            nums[l] = nums[r]
            nums[r] = -1
            r--
            continue
        }
        l++
    }
    return l
}
```

### [977]æœ‰åºæ•°ç»„çš„å¹³æ–¹

ã€é“¾æ¥ã€‘ï¼š<https://leetcode.cn/problems/squares-of-a-sorted-array/>
ã€é¢˜ç›®æè¿°ã€‘ï¼š
ç»™ä½ ä¸€ä¸ªæŒ‰ **éé€’å‡é¡ºåº** æ’åºçš„æ•´æ•°æ•°ç»„ `nums`ï¼Œè¿”å› **æ¯ä¸ªæ•°å­—çš„å¹³æ–¹** ç»„æˆçš„æ–°æ•°ç»„ï¼Œè¦æ±‚ä¹ŸæŒ‰ **éé€’å‡é¡ºåº** æ’åºã€‚

**ç¤ºä¾‹ 1ï¼š**

```plaintext
è¾“å…¥ï¼šnums = [-4,-1,0,3,10]
è¾“å‡ºï¼š[0,1,9,16,100]
è§£é‡Šï¼šå¹³æ–¹åï¼Œæ•°ç»„å˜ä¸º [16,1,0,9,100]
æ’åºåï¼Œæ•°ç»„å˜ä¸º [0,1,9,16,100]
```

**ç¤ºä¾‹ 2ï¼š**

```plaintext
è¾“å…¥ï¼šnums = [-7,-3,2,3,11]
è¾“å‡ºï¼š[4,9,9,49,121]
```

**æç¤ºï¼š**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` å·²æŒ‰ **éé€’å‡é¡ºåº** æ’åº

**è¿›é˜¶ï¼š**

- è¯·ä½ è®¾è®¡æ—¶é—´å¤æ‚åº¦ä¸º `O(n)` çš„ç®—æ³•è§£å†³æœ¬é—®é¢˜

ã€é¢˜è§£ã€‘å¯¹äºæœ‰åºæ•°ç»„çš„å¹³æ–¹ï¼Œæ ¸å¿ƒæ€æƒ³ä¾æ—§æ˜¯å·¦å³åŒæŒ‡é’ˆï¼Œç›´æ¥æ¯”è¾ƒå·¦å³åŒæŒ‡é’ˆçš„å¹³æ–¹å¤§å°ï¼Œç„¶åä»å³å¾€å·¦å¡«å…¥æœ€å¤§å€¼ã€‚
ä½†æ˜¯èµ·åˆè‡ªå·±çš„æƒ³æ³•æœ‰ç‚¹ç›´ç™½ï¼Œæœ‰ç‚¹æ­ªï¼Œæƒ³å…ˆæ‰¾åˆ°ä¸­é—´å€¼ï¼Œè¿™æ ·å°±åˆ†ä¸ºä¸‰ç§æƒ…å†µï¼Œ1. æ•°ç»„ä¸­çš„nums[i] <= 0 ï¼Œ2. æ•°ç»„ä¸­çš„nums[i] >= 0ï¼Œ3. æ•°ç»„ä¸­çš„nums[i] <= 0, nums[j] >= 0ã€‚è¿™é‡Œå…¶å®ä¸ç”¨åˆ†ï¼Œç›´æ¥ä½¿ç”¨å·¦å³åŒæŒ‡é’ˆè¿›è¡Œæ¯”è¾ƒå³å¯ã€‚

ã€ä»£ç ã€‘

```go
// sortedSquares æœ‰åºæ•°ç»„çš„å¹³æ–¹
func sortedSquares(nums []int) []int {
	n := len(nums)
	i, j, k := 0, n-1, n-1
	ans := make([]int, n)
	for i <= j {
		lm, rm := nums[i]*nums[i], nums[j]*nums[j]
		if lm > rm {
			ans[k] = lm
			i++
		} else {
			ans[k] = rm
			j--
		}
		k--
	}
	return ans
}

// sortedSquares2 æ’åºæ³•
func sortedSquares2(nums []int) []int {
    for i, val := range nums {
        nums[i] *= val
    }
    sort.Ints(nums)
    return nums
}

func sortedSquares3(nums []int) []int {
    if len(nums) == 1 {
        return []int{nums[0]*nums[0]}
    }
    // 1. å…ˆæ‰¾åˆ°åˆ†ç•Œç‚¹
    // å®Œå…¨æ˜¯è´Ÿçš„ï¼Œå®Œå…¨æ˜¯æ­£çš„ï¼Œæœ‰æ­£è´Ÿåˆ†ç•Œç‚¹çš„
    l, r := 0, 1
    for r < len(nums) - 1 {
        if nums[l] < 0 && nums[r] < 0 {
            l++
            r++
        }
        if nums[l] < 0 && 0 <= nums[r] {
            break
        }
        if 0 <= nums[l] {
            break
        }
    }

	// 2. ä»åˆ†ç•Œç‚¹å¼€å§‹ï¼Œå·¦å³ä¸¤è¾¹åˆ†åˆ«å‘ä¸¤è¾¹æ‰©æ•£
    var result []int
    if l == 0 && r == 1 && 0 <= nums[0]{
        for i := 0; i < len(nums); i++ {
            result = append(result, nums[i]*nums[i])
        }
        return result
    }
    for 0 <= l && r < len(nums) {
        if nums[l]*nums[l] <= nums[r]*nums[r] {
            result = append(result, nums[l]*nums[l])
            l--
        } else {
            result = append(result, nums[r]*nums[r])
            r++
        }
    }
    if 0 <= l {
        for 0 <= l {
            result = append(result, nums[l]*nums[l])
            l--
        }
    }
    if r < len(nums) {
        for r < len(nums) {
            result = append(result, nums[r]*nums[r])
            r++
        }
    }
    return result
}
```

## 3. æ ˆ

## 4. é˜Ÿåˆ—

## 5. å“ˆå¸Œè¡¨

## 6. æ ‘

## 7. å †

## 8. å›¾

## 9. æœç´¢

## 10. æ’åº

## 11. åˆ†æ²»

## 12. å›æº¯

## 13. åŠ¨æ€è§„åˆ’

## 14. è´ªå¿ƒ
